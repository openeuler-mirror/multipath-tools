From 2870e594978f683a97f32a8f9d8ed1747caae60e Mon Sep 17 00:00:00 2001
From: sunguoshuai <sunguoshuai@huawei.com>
Date: Tue, 22 Jan 2019 22:00:35 -0500
Subject: [PATCH] avoid handling paths repeatedly in coalesce paths

reason:fix lun expansion failure when there is offline path
---
 libmultipath/configure.c   | 11 +++++++++++
 libmultipath/structs.c     |  1 +
 libmultipath/structs.h     |  1 +
 libmultipath/structs_vec.c |  1 +
 4 files changed, 14 insertions(+)

diff --git a/libmultipath/configure.c b/libmultipath/configure.c
index 6fb477f..ff65c1b 100644
--- a/libmultipath/configure.c
+++ b/libmultipath/configure.c
@@ -1166,6 +1166,7 @@ int coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid,
 
 	vector_foreach_slot (pathvec, pp1, k) {
 		int invalid;
+               condlog(3, "%s %s: start coalesce", pp1->dev, pp1->dev_t);
 		/* skip this path for some reason */
 
 		/* 1. if path has no unique id or wwid blacklisted */
@@ -1202,6 +1203,12 @@ int coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid,
 			orphan_path(pp1, "only one path");
 			continue;
 		}
+                /* if path is handled before */
+                if (pp1->handled) {
+                        condlog(3, "%s: skip handled path.", pp1->dev_t);
+                        continue;
+                }
+
 
 		/*
 		 * at this point, we know we really got a new mp
@@ -1220,6 +1227,10 @@ int coalesce_paths (struct vectors * vecs, vector newmp, char * refwwid,
 
 		for (i = k + 1; i < VECTOR_SIZE(pathvec); i++) {
 			pp2 = VECTOR_SLOT(pathvec, i);
+                        if (pp2->handled)
+                                continue;
+
+
 
 			if (strcmp(pp1->wwid, pp2->wwid))
 				continue;
diff --git a/libmultipath/structs.c b/libmultipath/structs.c
index 464596f..e5de0a7 100644
--- a/libmultipath/structs.c
+++ b/libmultipath/structs.c
@@ -101,6 +101,7 @@ alloc_path (void)
 		pp->fd = -1;
 		pp->tpgs = TPGS_UNDEF;
 		pp->priority = PRIO_UNDEF;
+		pp->handled = 0;
 		pp->checkint = CHECKINT_UNDEF;
 		checker_clear(&pp->checker);
 		dm_path_to_gen(pp)->ops = &dm_gen_path_ops;
diff --git a/libmultipath/structs.h b/libmultipath/structs.h
index 7de93d6..022ba12 100644
--- a/libmultipath/structs.h
+++ b/libmultipath/structs.h
@@ -280,6 +280,7 @@ struct path {
 	struct checker checker;
 	struct multipath * mpp;
 	int fd;
+	int handled;
 	int initialized;
 	int retriggers;
 	unsigned int path_failures;
diff --git a/libmultipath/structs_vec.c b/libmultipath/structs_vec.c
index 8895fa7..8676081 100644
--- a/libmultipath/structs_vec.c
+++ b/libmultipath/structs_vec.c
@@ -738,6 +738,7 @@ int verify_paths(struct multipath *mpp)
 		return 0;
 
 	vector_foreach_slot (mpp->paths, pp, i) {
+               pp->handled = 1;
 		/*
 		 * see if path is in sysfs
 		 */
-- 
1.8.3.1

