From 3142e137afb8dd2bd99398d05b3c24ac9a9fd68e Mon Sep 17 00:00:00 2001
From: "wangjun196@huawei.com" <wangjun196@huawei.com>
Date: Thu, 16 Jul 2020 18:03:30 +0800
Subject: [PATCH] 1

---
 libmpathpersist/mpath_persist.c  | 12 ++++++++++--
 libmpathpersist/mpath_pr_ioctl.c | 28 ++++++++++++++--------------
 2 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/libmpathpersist/mpath_persist.c b/libmpathpersist/mpath_persist.c
index 3da7a6c..0ae504e 100644
--- a/libmpathpersist/mpath_persist.c
+++ b/libmpathpersist/mpath_persist.c
@@ -244,10 +244,14 @@ static int mpath_get_map(int fd, char **palias, struct multipath **pmpp)
 
 	if (dm_map_present(alias) && dm_is_mpath(alias) != 1){
 		condlog(3, "%s: not a multipath device.", alias);
+		if (curmp)
+			vector_free(curmp);
+		if (pathvec)
+			vector_free(pathvec);
 		goto out;
 	}
 
-	/* get info of all paths from the dm device     */
+	/* get info of all paths from the dm device */
 	if (get_mpvec(curmp, pathvec, alias)){
 		condlog(0, "%s: failed to get device info.", alias);
 		goto out;
@@ -823,7 +827,7 @@ out:
 	return (status);
 }
 
-void * mpath_alloc_prin_response(int prin_sa)
+void *mpath_alloc_prin_response(int prin_sa)
 {
 	void * ptr = NULL;
 	int size=0;
@@ -846,6 +850,10 @@ void * mpath_alloc_prin_response(int prin_sa)
 	if (size > 0)
 	{
 		ptr = calloc(size, 1);
+		if (!ptr) {
+			condlog (0,  "failed to allocate MPATH_PRIN_RFSTAT_SA buffer");
+			return NULL;
+		}
 	}
 	return ptr;
 }
diff --git a/libmpathpersist/mpath_pr_ioctl.c b/libmpathpersist/mpath_pr_ioctl.c
index 74b26b0..8a78693 100644
--- a/libmpathpersist/mpath_pr_ioctl.c
+++ b/libmpathpersist/mpath_pr_ioctl.c
@@ -23,8 +23,8 @@
 #define MAXRETRY 5
 
 int prin_do_scsi_ioctl(char * dev, int rq_servact, struct prin_resp *resp, int noisy);
-int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr,
-			      SenseData_t *Sensedata);
+int mpath_translate_response (const char * dev, struct sg_io_hdr *io_hdr,
+			      const SenseData_t *Sensedata);
 void dumpHex(const char* str, int len, int no_ascii);
 int prout_do_scsi_ioctl( char * dev, int rq_servact, int rq_scope,
 		unsigned int rq_type, struct prout_param_descriptor *paramp, int noisy);
@@ -113,7 +113,7 @@ retry :
 
 	condlog(4, "%s: Duration=%u (ms)", dev, io_hdr.duration);
 
-	status = mpath_translate_response(dev, io_hdr, &Sensedata);
+	status = mpath_translate_response(dev, &io_hdr, &Sensedata);
 	condlog(3, "%s: status = %d", dev, status);
 
 	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
@@ -359,7 +359,7 @@ retry :
 	condlog(3, "%s: duration = %u (ms)", dev, io_hdr.duration);
 	condlog(4, "%s: persistent reservation in: requested %d bytes but got %d bytes)", dev, mx_resp_len, got);
 
-	status = mpath_translate_response(dev, io_hdr, &Sensedata);
+	status = mpath_translate_response(dev, &io_hdr, &Sensedata);
 
 	if (status == MPATH_PR_SENSE_UNIT_ATTENTION && (retry > 0))
 	{
@@ -404,18 +404,18 @@ out:
 	return status;
 }
 
-int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr,
-			      SenseData_t *Sensedata)
+int mpath_translate_response (const char *dev, struct sg_io_hdr *io_hdr,
+			      const SenseData_t *Sensedata)
 {
 	condlog(3, "%s: status driver:%02x host:%02x scsi:%02x", dev,
-			io_hdr.driver_status, io_hdr.host_status ,io_hdr.status);
-	io_hdr.status &= 0x7e;
-	if ((0 == io_hdr.status) &&
-	    (0 == io_hdr.host_status) &&
-	    (0 == io_hdr.driver_status))
+			io_hdr->driver_status, io_hdr->host_status ,io_hdr->status);
+	io_hdr->status &= 0x7e;
+	if ((0 == io_hdr->status) &&
+	    (0 == io_hdr->host_status) &&
+	    (0 == io_hdr->driver_status))
 		return MPATH_PR_SUCCESS;
 
-	switch(io_hdr.status) {
+	switch(io_hdr->status) {
 	case SAM_STAT_GOOD:
 		break;
 	case SAM_STAT_CHECK_CONDITION:
@@ -455,13 +455,13 @@ int mpath_translate_response (char * dev, struct sg_io_hdr io_hdr,
 		return  MPATH_PR_OTHER;
 	}
 
-	switch(io_hdr.host_status) {
+	switch(io_hdr->host_status) {
 	case DID_OK :
 		break;
 	default :
 		return MPATH_PR_OTHER;
 	}
-	switch(io_hdr.driver_status)
+	switch(io_hdr->driver_status)
 	{
 	case DRIVER_OK:
 		break;
-- 
1.8.3.1

